class VulnerabilityAnalyzer {
  constructor() {
    this.patterns = this.initializePatterns();
  }

  initializePatterns() {
    return [
      {
        id: 'REENTRANCY',
        name: 'Reentrancy Attack',
        pattern: /\.call\s*\{[^}]*\}\s*\([^)]*\)|\.call\([^)]*\)(?!\s*\.success)/g,
        severity: 'high',
        category: 'External Calls',
        description: 'Potential reentrancy vulnerability detected. External calls before state changes can allow attackers to re-enter the function.',
        recommendation: 'Use the checks-effects-interactions pattern: perform all checks first, then update state, and finally make external calls. Consider using ReentrancyGuard.',
        cwe: 'CWE-841',
        owasp: 'A10',
        references: [
          'https://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/',
          'https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol'
        ]
      },
      {
        id: 'INTEGER_OVERFLOW',
        name: 'Integer Overflow/Underflow',
        pattern: /(?:uint\d*|int\d*)\s+\w+\s*[+\-*/]\s*\w+(?!\s*=)/g,
        severity: 'medium',
        category: 'Arithmetic',
        description: 'Arithmetic operations without overflow protection detected.',
        recommendation: 'Use SafeMath library for Solidity < 0.8.0 or ensure you are using Solidity 0.8+ with built-in overflow checks.',
        cwe: 'CWE-190',
        owasp: 'A04'
      },
      {
        id: 'UNPROTECTED_SELFDESTRUCT',
        name: 'Unprotected Selfdestruct',
        pattern: /selfdestruct\s*\([^)]*\)(?![^{]*(?:onlyOwner|require|modifier|msg\.sender\s*==))/g,
        severity: 'high',
        category: 'Access Control',
        description: 'Selfdestruct function without proper access control can be exploited by attackers.',
        recommendation: 'Add access control modifiers like onlyOwner or implement proper authorization checks.',
        cwe: 'CWE-284',
        owasp: 'A01'
      },
      {
        id: 'TX_ORIGIN_USAGE',
        name: 'tx.origin Authentication',
        pattern: /tx\.origin/g,
        severity: 'medium',
        category: 'Authentication',
        description: 'Use of tx.origin for authorization is vulnerable to phishing attacks.',
        recommendation: 'Use msg.sender instead of tx.origin for authorization checks.',
        cwe: 'CWE-346',
        owasp: 'A07'
      },
      {
        id: 'UNCHECKED_EXTERNAL_CALL',
        name: 'Unchecked External Call',
        pattern: /\.call\([^)]*\)(?!\s*(?:\.success|&&|\|\||require|assert))/g,
        severity: 'medium',
        category: 'External Calls',
        description: 'External call return value not checked, which can lead to silent failures.',
        recommendation: 'Always check the return value of external calls and handle failures appropriately.',
        cwe: 'CWE-252',
        owasp: 'A09'
      },
      {
        id: 'WEAK_RANDOMNESS',
        name: 'Weak Randomness Source',
        pattern: /(?:block\.timestamp|block\.difficulty|block\.number|blockhash)\s*[%*+\-\/]/g,
        severity: 'medium',
        category: 'Randomness',
        description: 'Using block properties for randomness is predictable and can be manipulated by miners.',
        recommendation: 'Use secure randomness sources like Chainlink VRF or commit-reveal schemes.',
        cwe: 'CWE-338',
        owasp: 'A02'
      },
      {
        id: 'MISSING_ACCESS_CONTROL',
        name: 'Missing Access Control',
        pattern: /function\s+\w+\s*\([^)]*\)\s*(?:public|external)(?!\s+(?:view|pure))(?![^{]*(?:onlyOwner|require.*msg\.sender|modifier\s+\w+))/g,
        severity: 'medium',
        category: 'Access Control',
        description: 'State-changing function without access control detected.',
        recommendation: 'Add appropriate access control modifiers or require statements.',
        cwe: 'CWE-284',
        owasp: 'A01'
      },
      {
        id: 'DANGEROUS_DELEGATECALL',
        name: 'Dangerous Delegatecall',
        pattern: /delegatecall\s*\([^)]*\)/g,
        severity: 'high',
        category: 'External Calls',
        description: 'Delegatecall executes code in the context of the calling contract, which can be dangerous.',
        recommendation: 'Ensure delegatecall target is trusted, validated, and cannot be controlled by users.',
        cwe: 'CWE-829',
        owasp: 'A08'
      },
      {
        id: 'TIMESTAMP_DEPENDENCE',
        name: 'Timestamp Dependence',
        pattern: /block\.timestamp|now(?!\w)/g,
        severity: 'low',
        category: 'Time',
        description: 'Contract logic depends on block timestamp, which can be manipulated by miners.',
        recommendation: 'Avoid using timestamp for critical logic or use block numbers with appropriate tolerance.',
        cwe: 'CWE-829',
        owasp: 'A04'
      },
      {
        id: 'UNINITIALIZED_STORAGE',
        name: 'Uninitialized Storage Pointer',
        pattern: /struct\s+\w+\s+\w+;(?!\s*\w+\s*=)/g,
        severity: 'high',
        category: 'Storage',
        description: 'Uninitialized storage pointers can overwrite arbitrary storage slots.',
        recommendation: 'Always initialize storage variables or use memory/calldata for temporary structs.',
        cwe: 'CWE-824',
        owasp: 'A06'
      }
    ];
  }

  async analyze(contractCode, options = {}) {
    const vulnerabilities = [];
    const lines = contractCode.split('\n');

    for (const pattern of this.patterns) {
      const matches = [...contractCode.matchAll(pattern.pattern)];
      
      for (const match of matches) {
        const lineNumber = this.getLineNumber(contractCode, match.index);
        const contextLines = this.getContext(lines, lineNumber, 2);
        
        vulnerabilities.push({
          id: pattern.id,
          name: pattern.name,
          severity: pattern.severity,
          category: pattern.category,
          description: pattern.description,
          recommendation: pattern.recommendation,
          cwe: pattern.cwe,
          owasp: pattern.owasp,
          location: {
            line: lineNumber,
            column: this.getColumnNumber(contractCode, match.index),
            length: match[0].length
          },
          code: {
            snippet: match[0],
            context: contextLines
          },
          references: pattern.references || [],
          confidence: this.calculateConfidence(pattern, match, contractCode),
          impact: this.assessImpact(pattern, contractCode)
        });
      }
    }

    // Sort by severity and confidence
    return vulnerabilities.sort((a, b) => {
      const severityOrder = { high: 3, medium: 2, low: 1 };
      if (severityOrder[a.severity] !== severityOrder[b.severity]) {
        return severityOrder[b.severity] - severityOrder[a.severity];
      }
      return b.confidence - a.confidence;
    });
  }

  getLineNumber(content, index) {
    return content.substring(0, index).split('\n').length;
  }

  getColumnNumber(content, index) {
    const lines = content.substring(0, index).split('\n');
    return lines[lines.length - 1].length + 1;
  }

  getContext(lines, lineNumber, contextSize) {
    const start = Math.max(0, lineNumber - contextSize - 1);
    const end = Math.min(lines.length, lineNumber + contextSize);
    
    return lines.slice(start, end).map((line, index) => ({
      number: start + index + 1,
      code: line,
      highlight: start + index + 1 === lineNumber
    }));
  }

  calculateConfidence(pattern, match, contractCode) {
    // Base confidence
    let confidence = 0.7;

    // Increase confidence based on pattern specificity
    if (pattern.id === 'REENTRANCY') {
      // Check if it's in a payable function
      const functionMatch = contractCode.substring(0, match.index).match(/function\s+\w+[^{]*payable[^{]*$/);
      if (functionMatch) confidence += 0.2;
      
      // Check if state is modified after external call
      const afterCall = contractCode.substring(match.index + match[0].length, match.index + match[0].length + 200);
      if (/\w+\s*[=+-]/g.test(afterCall)) confidence += 0.1;
    }

    return Math.min(1.0, confidence);
  }

  assessImpact(pattern, contractCode) {
    const impacts = {
      'REENTRANCY': 'Contract funds can be drained through recursive calls',
      'UNPROTECTED_SELFDESTRUCT': 'Contract can be permanently destroyed by anyone',
      'DANGEROUS_DELEGATECALL': 'Arbitrary code execution in contract context',
      'INTEGER_OVERFLOW': 'Arithmetic operations may overflow causing unexpected behavior',
      'TX_ORIGIN_USAGE': 'Vulnerable to phishing attacks through intermediate contracts',
      'UNCHECKED_EXTERNAL_CALL': 'Silent failures may leave contract in inconsistent state',
      'WEAK_RANDOMNESS': 'Predictable random values can be exploited',
      'MISSING_ACCESS_CONTROL': 'Unauthorized users can execute privileged functions',
      'TIMESTAMP_DEPENDENCE': 'Miners can manipulate execution timing',
      'UNINITIALIZED_STORAGE': 'Storage corruption and unexpected behavior'
    };

    return impacts[pattern.id] || 'Potential security vulnerability';
  }

  getSupportedRules() {
    return this.patterns.map(p => ({
      id: p.id,
      name: p.name,
      severity: p.severity,
      category: p.category,
      cwe: p.cwe,
      owasp: p.owasp
    }));
  }
}

module.exports = VulnerabilityAnalyzer;